<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Functional Programming is not just Lambda Functions</title>
		<meta name="description" content="">
		<meta name="author" content="David Sferruzza">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/sp.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement('link');
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName('head')[0].appendChild(link);
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown data-separator="^\r?\n---\r?\n$">
					<textarea data-template>
# Functional Programming is not just Lambda Functions
## David Sferruzza
### 2017-05-16

![Codemotion](img/codemotion.png) <!-- .element: width="300" height="auto" -->

---

# About me

- [@d_sferruzza](https://twitter.com/d_sferruzza)
- [github.com/dsferruzza](https://github.com/dsferruzza)
- Head of Research and Development at [Startup Palace](https://www.startup-palace.com)
- PhD student in software engineering at *University of Nantes*

![](img/sp.gif) <!-- .element: class="stretch" -->

---

# FP is for Functional Programming

> FP is a **declarative** programming paradigm, which means programming is done with **expressions**.

It is becoming more and more popular.

![](img/fp.png) <!-- .element: class="stretch" -->

---

# Declarative vs. imperative

> **Imperative programming**: use statements that change a program's state
>
> **Declarative programming**: express the logic of a computation without describing its control flow

- imperative: shopping instructions
- declarative: shopping list

---

# Lambda functions

*also called __anonymous function__*

```javascript
// &#x25BC; regular function
function myFunction(foo) {
  return foo + 1;
}
//                     &#x25BC; lambda function
var myLambdaFunction = function(foo) {
  return foo + 1;
}
//                     &#x25BC; lambda function
var myLambdaFunction = foo => foo + 1;
```

---

# &#955;-calculus

- Alonzo Church (1930s)
- formal system for expressing computation
- equivalent to the Turing machine

![](img/lambda-calculus.jpg) <!-- .element: class="stretch" -->

<small>See: [The Lambda Calculus and The JavaScript](http://fr.slideshare.net/normanrichards/the-lambda-calculus-and-the-javascript)</small>

---

# Learning FP is like...

- learning **new ways to think** about programming
- **writting better code** right now
  - even with *non-functional* languages

![](img/reindeer.gif) <!-- .element: class="stretch" -->

Languages that allow to use some **FP concepts**:
- FP languages (Haskell, Scala, Erlang, ...)
- a lot of *non-FP* langages \o/ (like JS)

---

# Concepts

Let's explore some FP concepts:

- referential transparency
- higher-order functions
- lazy evaluation
- immutability

and apply them with JS!
					</textarea>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>
		<script src="plugin/markdown/marked.js"></script>

		<script>
			function paragraphRenderer(text) {
				var singleImage = text.match(/^(<img src=".+" alt=".*">)(\s*<!--.+-->)?$/);
				if (singleImage !== null) {
					var stretchComment = (typeof singleImage[2] === 'string') ? singleImage[2].match(/^\s*<!--\s*\.element:\s*(.*?)\s*(class\s*=\s*"stretch")\s*(.*?)\s*-->$/) : null;
					if (stretchComment !== null && typeof stretchComment[2] === 'string') {
						var comment = '<!-- .element: ' + ((typeof stretchComment[1] === 'string') ? stretchComment[1] : '') + ' ' + ((typeof stretchComment[3] === 'string') ? stretchComment[3] : '') + ' -->';
						return '<figure class="stretch">' + singleImage[1] + comment + '</figure>';
					}
					else {
						var comment = (typeof singleImage[2] === 'string') ? singleImage[2] : '';
						return '<figure>' + singleImage[1] + comment + '</figure>';
					}
				}
				else {
					return '<p>' + text + '</p>\n';
				}
			}
			var patchedRenderer = new marked.Renderer();
			patchedRenderer.paragraph = paragraphRenderer;

			Reveal.initialize({
				controls: false,
				slideNumber: true,
				history: true,
				transition: 'none',
				dependencies: [
					// { src: 'plugin/markdown/marked.js' }, // <-- useless because included before
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
				],
				markdown: {
					renderer: patchedRenderer,
				},
			});
		</script>
	</body>
</html>
